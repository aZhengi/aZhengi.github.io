






<!doctype html>
<html lang="zh-Hans">
<head>
  <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <meta name="author" content="Life">
  
  
  
  
    <meta name="description" content="解构是一个将数据结构分解为更小的部分的过程。本章介绍如何在对象与数组上利用解构。
解构为何有用？在ES5及更早版中。从对象或数组中获取信息、并将特定数据存入本地变量，需要书写许多并且相似的代码。例如：
12345678let options = &#123;  repeat: true,  save: false&#125;;//从对象中提取数据let repeat = options.re...">
  
  <title>解构：更方便的数据访问 [ Life ]</title>
  
  
    <link rel="shortcut icon" href="/favicon.ico">
  
  
  <link rel="stylesheet" href="/css/random.css">
<link rel="stylesheet" href="/css/vegas.min.css">
<link rel="stylesheet" href="/css/highlight-railscasts.css">
<link rel="stylesheet" href="/css/jquery.fancybox.css">
<link rel="stylesheet" href="/css/iconfont/iconfont.css">
<link rel="stylesheet" href="/css/jquery.fancybox-thumbs.css">
<link rel="stylesheet" href="/css/plyr.css">
  
</head>

<body>
<div class="side-navigate hide-area">
  
    <div class="item prev">
      <a href="/2017/04/25/Flex布局/">
        <div class="item-icon"></div>
      </a>
      <div class="item-title">
        老生常谈的Flex布局
      </div>
    </div>
  
  
</div>
<div id="outer-container" class="hide-area">
<div id="container">
  <div id="menu-outer" class="slide-down">
    <div id="menu-inner">
      <div id="brand">
        
        <a onClick="openUserCard()">
          <img id="avatar" src="http://7te9fe.com1.z0.glb.clouddn.com/default_avatar.jpg"/>
          <div id="homelink">Life</div>
        </a>
      </div>
      <div id="menu-list">
        <ul>
        
        
          
            <li>
          
            <a href="/index.html">Home</a>
            
          </li>
        
          
            <li>
          
            <a href="/archives">Archives</a>
            
          </li>
        
          
            <li>
          
            <a href="/tags">Tags</a>
            
          </li>
        
          
            <li>
          
            <a href="/categories">Categories</a>
            
          </li>
        
          
            <li>
          
            <a href="/about">About</a>
            
          </li>
        
        </ul>
      </div>
      <div id="show-menu">
        <button>Menu</button>
      </div>
    </div>
  </div>

  <div id="content-outer">
    <div id="content-inner">
      
      
  <article id="post">
    <h1>解构：更方便的数据访问</h1>
    <p class="page-title-sub">
      <span id = "post-title-date">Created at 2017-04-26</span>
      
        <span id = "post-title-updated">Updated at 2017-04-26</span>
      
      
      
    </p>
    
    <p>解构是一个将数据结构分解为更小的部分的过程。本章介绍如何在对象与数组上利用解构。</p>
<h2 id="解构为何有用？"><a href="#解构为何有用？" class="headerlink" title="解构为何有用？"></a>解构为何有用？</h2><p>在<code>ES5</code>及更早版中。从对象或数组中获取信息、并将特定数据存入本地变量，需要书写许多并且相似的代码。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> options = &#123;</div><div class="line">  <span class="attr">repeat</span>: <span class="literal">true</span>,</div><div class="line">  <span class="attr">save</span>: <span class="literal">false</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="comment">//从对象中提取数据</span></div><div class="line"><span class="keyword">let</span> repeat = options.repeat,</div><div class="line">save = options.save;</div></pre></td></tr></table></figure>
<p>此代码提取了 <code>options</code> 对象的 <code>repeat</code> 与 <code>save</code> 值，并将其储存在同名的本地变量上。虽然这段代码看起来简单，但想象一下如果有大量变量需要处理，你就得逐个为其赋值；并且若有一个嵌套的数据结构需要遍历以寻找信息，你可能会为了一点数据而挖掘整个结构。</p>
<p>这就是 <code>ES6</code> 为何要给对象与数组添加解构。当把数据结构分解为更小的部分时，从中提取你要的数据会变得容易许多。很多语言都能用精简的语法来实现解构，让它更易使用。 <code>ES6</code> 的解构实际使用的语法其实你早已熟悉，那就是对象与数组的字面量语法。</p>
<h2 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h2><p>对象解构语法在赋值语句的左侧使用了对象字面量，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">        <span class="attr">name</span>: <span class="string">"foo"</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; type, name &#125; = node;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(type);      <span class="comment">// "Identifier"</span></div><div class="line"><span class="built_in">console</span>.log(name);      <span class="comment">// "foo"</span></div></pre></td></tr></table></figure>
<p>在此代码中， <code>node.type</code> 的值被存储到 <code>type</code> 本地变量中， <code>node.name</code> 的值则存储到 <code>name</code> 变量中。此语法相同于第四章介绍的简写的属性初始化器。 <code>type</code> 与 <code>name</code> 标识符既声明了本地变量，也读取了对象的相应属性值。</p>
<blockquote>
<p><strong>不要遗忘初始化器</strong></p>
<p>当使用解构来声明变量时，必须提供初始化器(即等号右边的值)。下面的代码都会因为缺失初始化器而抛出错误：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">&gt;<span class="comment">// 语法错误！</span></div><div class="line">&gt;<span class="keyword">var</span> &#123; type, name &#125;;</div><div class="line">&gt;</div><div class="line">&gt;<span class="comment">// 语法错误！</span></div><div class="line">&gt;<span class="keyword">let</span> &#123; type, name &#125;;</div><div class="line">&gt;</div><div class="line">&gt;<span class="comment">// 语法错误！</span></div><div class="line">&gt;<span class="keyword">const</span> &#123; type, name &#125;;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p><code>const</code>总是要求有初始化器，即便不是解构赋值。</p>
</blockquote>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>以上对象解构示例都用于变量声明。不过，也可以在赋值语句中使用解构。例如，你可能想在变量声明之后改变它们的值，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">  <span class="attr">type</span>: <span class="string">'Identifier'</span>,</div><div class="line">  <span class="attr">name</span>: <span class="string">'foo'</span></div><div class="line">&#125;,</div><div class="line">type = <span class="string">'Literal'</span>,</div><div class="line">name = <span class="number">5</span>;</div><div class="line"></div><div class="line"><span class="comment">//使用解构来分配不同的值</span></div><div class="line">(&#123;type, name&#125; = node);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(type)	<span class="comment">//'Identifier'</span></div><div class="line"><span class="built_in">console</span>.log(name)	<span class="comment">//'foo'</span></div></pre></td></tr></table></figure>
<p>在本例中， <code>type</code> 与 <code>name</code> 属性在声明时被初始化，而两个同名变量也被声明并初始化为不同的值。接下来一行使用了解构表达式，通过读取 <code>node</code> 对象来更改这两个变量的值。注意你必须用圆括号包裹解构赋值语句，这是因为暴露的花括号会被解析为代码块语句，而块语句不允许在赋值操作符（即等号）左侧出现。圆括号标示了里面的花括号并不是块语句、而应该被解释为表达式，从而允许完成赋值操作。</p>
<p>解构赋值表达式的值为表达式右侧（在 <code>=</code> 之后）的值。也就是说在任何期望有个值的位置都可以使用解构赋值表达式。例如，传递值给函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">        <span class="attr">name</span>: <span class="string">"foo"</span></div><div class="line">    &#125;,</div><div class="line">    type = <span class="string">"Literal"</span>,</div><div class="line">    name = <span class="number">5</span>;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">outputInfo</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value === node);        <span class="comment">// true</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">outputInfo(&#123; type, name &#125; = node);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(type);      <span class="comment">// "Identifier"</span></div><div class="line"><span class="built_in">console</span>.log(name);      <span class="comment">// "foo"</span></div></pre></td></tr></table></figure>
<p><code>outputInfo()</code> 函数使用一个解构赋值表达式进行了调用。该表达式计算结果为 <code>node</code> ，因为这就是表达式右侧的值。对 <code>type</code> 与 <code>name</code> 的赋值正常进行，同时 <code>node</code> 也被传入了 <code>outputInfo()</code> 函数。</p>
<blockquote>
<p>当解构赋值表达式的右侧（ <code>=</code> 后面的表达式）的计算结果为 <code>null</code> 或 <code>undefined</code> 时，会抛出错误。因为任何读取 <code>null</code> 或 <code>undefined</code> 的企图都会导致“运行时”错误（ <code>runtime error</code>）。</p>
</blockquote>
<h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>当你使用解构赋值语句时，如果所指定的本地变量在对象中没有找到同名属性，那么该变量会被赋值为 <code>undefined</code> 。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">        <span class="attr">name</span>: <span class="string">"foo"</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; type, name, value &#125; = node;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(type);      <span class="comment">// "Identifier"</span></div><div class="line"><span class="built_in">console</span>.log(name);      <span class="comment">// "foo"</span></div><div class="line"><span class="built_in">console</span>.log(value);     <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<p>此代码定义了一个额外的本地变量 <code>value</code> ，并试图对其赋值。然而， <code>node</code> 对象中不存在同名属性，因此 <code>value</code> 不出预料地被赋值为 <code>undefined</code> 。</p>
<p>你可以选择性地定义一个默认值，以便在指定属性不存在时使用该值。若要这么做，需要在属性名后面添加一个等号并指定默认值，就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">        <span class="attr">name</span>: <span class="string">"foo"</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; type, name, value = <span class="literal">true</span> &#125; = node;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(type);      <span class="comment">// "Identifier"</span></div><div class="line"><span class="built_in">console</span>.log(name);      <span class="comment">// "foo"</span></div><div class="line"><span class="built_in">console</span>.log(value);     <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>在此例中，变量 <code>value</code> 被指定了一个默认值 <code>true</code> ，只有在 <code>node</code> 的对应属性缺失、或对应的属性值为 <code>undefined</code> 的情况下，该默认值才会被使用。由于此处不存在 <code>node.value</code> 属性，变量 <code>value</code> 就使用了该默认值。这种工作方式很像函数参数的默认值。</p>
<h3 id="赋值给不同的本地变量名"><a href="#赋值给不同的本地变量名" class="headerlink" title="赋值给不同的本地变量名"></a>赋值给不同的本地变量名</h3><p>至此的每个解构赋值示例都使用了对象中的属性名作为本地变量的名称，例如，把 <code>node.type</code> 的值存储到 <code>type</code> 变量上。若想使用相同名称，这么做就没问题，但若你不想呢？ <code>ES6</code> 有一个扩展语法，允许你在给本地变量赋值时使用一个不同的名称，而且该语法看上去就像是使用对象字面量的非简写的属性初始化。这里有个示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">        <span class="attr">name</span>: <span class="string">"foo"</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">type</span>: localType, <span class="attr">name</span>: localName &#125; = node;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(localType);     <span class="comment">// "Identifier"</span></div><div class="line"><span class="built_in">console</span>.log(localName);     <span class="comment">// "foo"</span></div></pre></td></tr></table></figure>
<p>此代码使用了解构赋值来声明 <code>localType</code> 与 <code>localName</code> 变量，分别获得了 <code>node.type</code> 与 <code>node.name</code> 属性的值。 <code>type: localType</code> 这种语法表示要读取名为 <code>type</code> 的属性，并把它的值存储在变量 <code>localType</code>上。该语法实际上与传统对象字面量语法相反，传统语法将名称放在冒号左边、值放在冒号右边；而在本例中，则是名称在右边，需要进行值读取的位置则被放在了左边。</p>
<p>你也可以给变量别名添加默认值，依然是在本地变量名称后添加等号与默认值，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">"Identifier"</span></div><div class="line">    &#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">type</span>: localType, <span class="attr">name</span>: localName = <span class="string">"bar"</span> &#125; = node;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(localType);     <span class="comment">// "Identifier"</span></div><div class="line"><span class="built_in">console</span>.log(localName);     <span class="comment">// "bar"</span></div></pre></td></tr></table></figure>
<p>此处的 <code>localName</code> 变量拥有一个默认值 <code>&quot;bar&quot;</code> ，该变量最终被赋予了默认值，因为 <code>node.name</code> 属性并不存在。</p>
<p>到此为止，你已经看到如何处理属性值为基本类型值的对象的解构，而对象解构也可被用于从嵌套的对象结构（即：对象的属性可能还是一个对象）中提取属性值。</p>
<h3 id="嵌套的对象解构"><a href="#嵌套的对象解构" class="headerlink" title="嵌套的对象解构"></a>嵌套的对象解构</h3><p>使用类似于对象字面量的语法，可以深入到嵌套的对象结构中去提取你想要的数据。这里有个示例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">        <span class="attr">name</span>: <span class="string">"foo"</span>,</div><div class="line">        <span class="attr">loc</span>: &#123;</div><div class="line">            <span class="attr">start</span>: &#123;</div><div class="line">                <span class="attr">line</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">column</span>: <span class="number">1</span></div><div class="line">            &#125;,</div><div class="line">            <span class="attr">end</span>: &#123;</div><div class="line">                <span class="attr">line</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">column</span>: <span class="number">4</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">loc</span>: &#123; start &#125;&#125; = node;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(start.line);        <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(start.column);      <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>本例中的解构模式使用了花括号，表示应当下行到 <code>node</code> 对象的 <code>loc</code> 属性内部去寻找 <code>start</code> 属性。记住上一节介绍过的，每当有一个冒号在解构模式中出现，就意味着冒号之前的标识符代表需要检查的位置，而冒号右侧则是赋值的目标。当冒号右侧存在花括号时，表示目标被嵌套在对象的更深一层中。</p>
<p>你还能更进一步，在对象的嵌套解构中同样能为本地变量使用不同的名称：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> node = &#123;</div><div class="line">        <span class="attr">type</span>: <span class="string">"Identifier"</span>,</div><div class="line">        <span class="attr">name</span>: <span class="string">"foo"</span>,</div><div class="line">        <span class="attr">loc</span>: &#123;</div><div class="line">            <span class="attr">start</span>: &#123;</div><div class="line">                <span class="attr">line</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">column</span>: <span class="number">1</span></div><div class="line">            &#125;,</div><div class="line">            <span class="attr">end</span>: &#123;</div><div class="line">                <span class="attr">line</span>: <span class="number">1</span>,</div><div class="line">                <span class="attr">column</span>: <span class="number">4</span></div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line"></div><div class="line"><span class="comment">// 提取 node.loc.start</span></div><div class="line"><span class="keyword">let</span> &#123; <span class="attr">loc</span>: &#123; <span class="attr">start</span>: localStart &#125;&#125; = node;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(localStart.line);   <span class="comment">// 1</span></div><div class="line"><span class="built_in">console</span>.log(localStart.column); <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>在此版本的代码中， <code>node.loc.start</code> 的值被存储在一个新的本地变量 <code>localStart</code> 上，解构模式可以被嵌套在任意深度的层级，并且在每个层级的功能都一样。</p>
<p>对象解构十分强大并有很多可用形式，而数组解构则提供了一些独特的能力，用于提取数组中的信息。</p>
<blockquote>
<p><strong>语法难点</strong></p>
<p>使用嵌套的解构时需要小心，因为你可能无意中就创建了一个没有任何效果的语句。空白花括号在对象解构中是合法的，然而它不会做任何事。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;<span class="comment">// 没有变量被声明！</span></div><div class="line">&gt;<span class="keyword">let</span> &#123; <span class="attr">loc</span>: &#123;&#125; &#125; = node;</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>在此语句中并未声明任何变量绑定。由于花括号在右侧， <code>loc</code> 被作为需检查的位置来使用，而不会创建变量绑定。这种情况仿佛是想用等号来定义一个默认值，但却被语法判断为想用冒号来定义一个位置。这种语法将来可能是非法的，然而现在它只是，需要留意的一个疑难点。</p>
</blockquote>
<h2 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h2><p>数组解构的语法看起来与对象解构非常相似，只是将对象字面量替换成了数组字面量。数组解构时，解构作用在数组内部的位置上，而不是作用在对象的具名属性上，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</div><div class="line"></div><div class="line"><span class="keyword">let</span> [ firstColor, secondColor ] = colors;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(firstColor);        <span class="comment">// "red"</span></div><div class="line"><span class="built_in">console</span>.log(secondColor);       <span class="comment">// "green"</span></div></pre></td></tr></table></figure>
<p>这里的数组解构从 <code>colors</code> 数组中取出了 <code>&quot;red&quot;</code> 与 <code>&quot;green&quot;</code> ，并将它们赋值给 <code>fristColor</code> 与 <code>secondColor</code> 变量。这些值被选择，是由于它们在数组中的位置，实际的变量名称是任意的（与位置无关）。任何<strong>没有在解构模式中明确指定</strong>的项都会被<strong>忽略</strong>。记住，数组本身并没有以任何方式被改变。</p>
<p>你也可以在解构模式中忽略一些项，并且只给感兴趣的项提供变量名。例如，若只想获取数组中的第三个元素，那么不必给前两项提供变量名。以下展示了这种方式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</div><div class="line"></div><div class="line"><span class="keyword">let</span> [ , , thirdColor ] = colors;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(thirdColor);        <span class="comment">// "blue"</span></div></pre></td></tr></table></figure>
<p>此代码使用了解构赋值来获取 <code>colors</code> 的第三个项。模式中 <code>thirdColor</code> 之前的逗号，是为数组前面的项提供的占位符。使用这种方法，你就可以轻易从数组任意位置取出值，而无须给其他项提供变量名。</p>
<blockquote>
<p>与对象解构相似，在使用 <code>var</code> 、 <code>let</code> 、 <code>const</code> 进行数组解构时，你必须提供初始化器。</p>
</blockquote>
<h3 id="解构赋值-1"><a href="#解构赋值-1" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>你可以在赋值表达式中使用数组解构，但是与对象解构不同，不必将表达式包含在圆括号内，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ],</div><div class="line">    firstColor = <span class="string">"black"</span>,</div><div class="line">    secondColor = <span class="string">"purple"</span>;</div><div class="line"></div><div class="line">[ firstColor, secondColor ] = colors;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(firstColor);        <span class="comment">// "red"</span></div><div class="line"><span class="built_in">console</span>.log(secondColor);       <span class="comment">// "green"</span></div></pre></td></tr></table></figure>
<p>此代码中解构赋值的工作方式与上例相似，唯一区别是 <code>firstColor</code> 与 <code>secondColor</code> 变量已经被声明过了。大多数情况下，以上可能就是数组解构赋值你需要了解的全部内容，但其实还有一个很细微却又可能很有用的用法。</p>
<p>数组解构赋值有一个非常独特的用例，能轻易地互换两个变量的值。互换变量值在排序算法中十分常用，而在 <code>ES5</code> 中需要使用第三个变量作为临时变量，正如下例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在 ES5 中互换值</span></div><div class="line"><span class="keyword">let</span> a = <span class="number">1</span>,</div><div class="line">    b = <span class="number">2</span>,</div><div class="line">    tmp;</div><div class="line"></div><div class="line">tmp = a;</div><div class="line">a = b;</div><div class="line">b = tmp;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a);     <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(b);     <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>其中的 <code>tmp</code> 变量对于互换 <code>a</code> 与 <code>b</code> 的值来说是必要的。然而若使用数组解构赋值，就不再需要这个额外变量。以下演示了在 <code>ES6</code> 中如何互换变量值：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在 ES6 中互换值</span></div><div class="line"><span class="keyword">let</span> a = <span class="number">1</span>,</div><div class="line">    b = <span class="number">2</span>;</div><div class="line"></div><div class="line">[ a, b ] = [ b, a ];</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(a);     <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(b);     <span class="comment">// 1</span></div></pre></td></tr></table></figure>
<p>本例中的数组解构赋值看起来如同镜像。赋值语句左侧（即等号之前）的解构模式正如其他数组解构的范例，右侧则是为了互换而临时创建的数组字面量。 <code>b</code> 与 <code>a</code> 的值分别被复制到临时数组的第一个与第二个位置，并对该数组进行解构，结果两个变量就互换了它们的值。</p>
<blockquote>
<p>与对象解构赋值相同，若等号右侧的计算结果为 <code>null</code> 或 <code>undefined</code> ，那么数组解构赋值表达式也会抛出错误。</p>
</blockquote>
<h3 id="默认值-1"><a href="#默认值-1" class="headerlink" title="默认值"></a>默认值</h3><p>数组解构赋值同样允许在数组任意位置指定默认值。当指定位置的项不存在、或其值为 <code>undefined</code> ，那么该默认值就会被使用。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span> ];</div><div class="line"></div><div class="line"><span class="keyword">let</span> [ firstColor, secondColor = <span class="string">"green"</span> ] = colors;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(firstColor);        <span class="comment">// "red"</span></div><div class="line"><span class="built_in">console</span>.log(secondColor);       <span class="comment">// "green"</span></div></pre></td></tr></table></figure>
<p>此代码的 <code>colors</code> 数组只有一个项，因此没有能与 <code>secondColor</code> 匹配的项，又由于此处有个默认值， <code>secondColor</code> 的值就被设置为 <code>&quot;green&quot;</code> ，而不是 <code>undefined</code> 。</p>
<h3 id="嵌套的解构"><a href="#嵌套的解构" class="headerlink" title="嵌套的解构"></a>嵌套的解构</h3><p>与解构嵌套的对象相似，可以用类似的方式来解构嵌套的数组。在整个解构模式中插入另一个数组模式，解构操作就会下行到嵌套的数组中，就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, [ <span class="string">"green"</span>, <span class="string">"lightgreen"</span> ], <span class="string">"blue"</span> ];</div><div class="line"></div><div class="line"><span class="comment">// 随后</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> [ firstColor, [ secondColor ] ] = colors;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(firstColor);        <span class="comment">// "red"</span></div><div class="line"><span class="built_in">console</span>.log(secondColor);       <span class="comment">// "green"</span></div></pre></td></tr></table></figure>
<p>此处的 <code>secondColor</code> 变量指向了 <code>colors</code> 数组中的 <code>&quot;green&quot;</code> 值，该项被包含在第二个数组中，因此解构模式就要把 <code>secondColor</code> 包裹上方括号。与对象解构相似，你也能使用任意深度的数组嵌套。</p>
<h3 id="剩余项"><a href="#剩余项" class="headerlink" title="剩余项"></a>剩余项</h3><p>第三章介绍过函数的剩余参数，而数组解构有个类似的、名为<strong>剩余项</strong>（ <strong>rest items</strong> ）的概念，它使用 <code>...</code>语法来将剩余的项目赋值给一个指定的变量，此处有个范例：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</div><div class="line"></div><div class="line"><span class="keyword">let</span> [ firstColor, ...restColors ] = colors;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(firstColor);        <span class="comment">// "red"</span></div><div class="line"><span class="built_in">console</span>.log(restColors.length); <span class="comment">// 2</span></div><div class="line"><span class="built_in">console</span>.log(restColors[<span class="number">0</span>]);     <span class="comment">// "green"</span></div><div class="line"><span class="built_in">console</span>.log(restColors[<span class="number">1</span>]);     <span class="comment">// "blue"</span></div></pre></td></tr></table></figure>
<p><code>colors</code> 数组的第一项被赋值给了 <code>firstColor</code> 变量，而剩余的则赋值给了一个新的 <code>restColors</code> 数组； <code>restColors</code> 数组则有两个项： <code>&quot;green&quot;</code> 与 <code>&quot;blue&quot;</code>。若要取出特定项并要求保留剩余的值，则剩余项是非常有用的，但它还有另一个有用的功能。</p>
<p>方便地克隆数组在 JS 中是个明显被遗漏的功能。在 <code>ES5</code> 中开发者往往使用的是一个简单的方式，也就是用 <code>concat()</code> 方法来克隆数组，例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在 ES5 中克隆数组</span></div><div class="line"><span class="keyword">var</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</div><div class="line"><span class="keyword">var</span> clonedColors = colors.concat();</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(clonedColors);      <span class="comment">//"[red,green,blue]"</span></div></pre></td></tr></table></figure>
<p>尽管 <code>concat()</code> 方法的本意是合并两个数组，但不使用任何参数来调用此方法，就会获得原数组的一个克隆品。而在 <code>ES6</code> 中，你可以使用剩余项的语法来达到同样效果。实现如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 在 ES6 中克隆数组</span></div><div class="line"><span class="keyword">let</span> colors = [ <span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span> ];</div><div class="line"><span class="keyword">let</span> [ ...clonedColors ] = colors;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(clonedColors);      <span class="comment">//"[red,green,blue]"</span></div></pre></td></tr></table></figure>
<p>在本例中，剩余项被用于将 <code>colors</code> 数组的值复制到 <code>clonedColors</code> 数组中。虽然从感觉上来说，使用这种技术未必让开发者复制数组的意图体现得比使用 <code>concat()</code> 方法更明显，但这依然是个值得关注的技巧。</p>
<p>剩余项必须是数组解构模式中最后的部分，之后不能再有逗号，否则就是语法错误。</p>
<h2 id="混合解构"><a href="#混合解构" class="headerlink" title="混合解构"></a>混合解构</h2><p>对象与数组解构能被用在一起，以创建更复杂的解构表达式。在对象与数组混合而成的结构中，这么做便能准确提取其中你想要的信息片段。例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">let node = &#123;</div><div class="line">        type: &quot;Identifier&quot;,</div><div class="line">        name: &quot;foo&quot;,</div><div class="line">        loc: &#123;</div><div class="line">            start: &#123;</div><div class="line">                line: 1,</div><div class="line">                column: 1</div><div class="line">            &#125;,</div><div class="line">            end: &#123;</div><div class="line">                line: 1,</div><div class="line">                column: 4</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        range: [0, 3]</div><div class="line">    &#125;;</div><div class="line"></div><div class="line">let &#123;</div><div class="line">    loc: &#123; start &#125;,</div><div class="line">    range: [ startIndex ]</div><div class="line">&#125; = node;</div><div class="line"></div><div class="line">console.log(start.line);        // 1</div><div class="line">console.log(start.column);      // 1</div><div class="line">console.log(startIndex);        // 0</div></pre></td></tr></table></figure>
<p>此代码将 <code>node.loc.start</code> 与 <code>node.range[0]</code> 提取出来，并将它们的值分别存储到 <code>start</code> 与 <code>startIndex</code> 中。要记住解构模式中的 <code>loc:</code> 与 <code>range:</code> 只是对应于 <code>node</code> 对象中属性的位置。混合使用对象与数组解构， <code>node</code> 的任何部分都能提取出来。对于从 JOSN 配置结构中抽取数据来说，这种方法尤其有用，因为它不需要探索整个结构。</p>
<h2 id="参数解构"><a href="#参数解构" class="headerlink" title="参数解构"></a>参数解构</h2><p>解构还有一个特别有用的场景，即在传递函数参数时。当 JS 的函数接收大量可选参数时，一个常用模式是创建一个 <code>options</code> 对象，其中包含了附加的参数，就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// options 上的属性表示附加参数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, options</span>) </span>&#123;</div><div class="line"></div><div class="line">    options = options || &#123;&#125;;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> secure = options.secure,</div><div class="line">        path = options.path,</div><div class="line">        domain = options.domain,</div><div class="line">        expires = options.expires;</div><div class="line"></div><div class="line">    <span class="comment">// 设置 cookie 的代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 第三个参数映射到 options</span></div><div class="line">setCookie(<span class="string">"type"</span>, <span class="string">"js"</span>, &#123;</div><div class="line">    <span class="attr">secure</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">expires</span>: <span class="number">60000</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>很多 JS 的库都包含了类似于此例的 <code>setCookie()</code> 函数。在此函数内， <code>name</code> 与 <code>value</code> 参数是必需的，而 <code>secure</code> 、 <code>path</code> 、 <code>domain</code> 与 <code>expires</code> 则不是。并且因为此处对于其余数据并没有顺序要求，将它们作为 <code>options</code> 对象的具名属性会更有效率，而无须列出一堆额外的具名参数。这种方法很有用，但无法仅通过查看函数定义就判断出函数所期望的输入，你必须阅读函数体的代码。</p>
<p>参数解构提供了更清楚地标明函数期望输入的替代方案。它使用对象或数组解构的模式替代了具名参数。要看到其实际效果，请查看下例中重写版本的 <code>setCookie()</code> 函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, &#123; secure, path, domain, expires &#125;</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// 设置 cookie 的代码</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">setCookie(<span class="string">"type"</span>, <span class="string">"js"</span>, &#123;</div><div class="line">    <span class="attr">secure</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">expires</span>: <span class="number">60000</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>此函数的行为类似上例，但此时第三个参数使用了解构来抽取必要的数据。现在对于 <code>setCookie()</code> 函数的使用者来说，解构参数之外的参数明显是必需的；而可选项目存在于额外的参数组中，这同样是非常明确的；同时，若使用了第三个参数，其中应当包含什么值当然也是极其明确的。解构参数在没有传递值的情况下类似于常规参数，它们会被设为 <code>undefined</code> 。</p>
<blockquote>
<p>参数解构拥有此前你在本文已经学过的其他解构方式的所有能力。你可以在其中使用默认参数、混合解构，或使用与属性不同的变量名。</p>
</blockquote>
<h3 id="解构的参数是必需的"><a href="#解构的参数是必需的" class="headerlink" title="解构的参数是必需的"></a>解构的参数是必需的</h3><p>参数解构有一个怪异点：默认情况下调用函数时未给参数解构传值会抛出错误。例如，用以下方式调用上例中的 <code>setCookie()</code> 函数就会出错：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 出错！</span></div><div class="line">setCookie(<span class="string">"type"</span>, <span class="string">"js"</span>);</div></pre></td></tr></table></figure>
<p>调用时第三个参数缺失了，因此它不出预料地等于 <code>undefined</code> 。这导致了一个错误，因为参数解构实际上只是解构声明的简写。当 <code>setCookie()</code> 函数被调用时， JS 引擎实际上是这么做的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, options</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">let</span> &#123; secure, path, domain, expires &#125; = options;</div><div class="line"></div><div class="line">    <span class="comment">// 设置 cookie 的代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>既然在赋值右侧的值为 <code>null</code> 或 <code>undefined</code> 时，解构会抛出错误，那么未向 <code>setCookie()</code> 函数传递第三个参数就同样会出错。</p>
<p>若你让解构的参数作为必选参数，那么上述行为并不会令人困扰。但若你要求它是可选的，可以给解构的参数提供默认值来处理这种行为，就像这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value, &#123; secure, path, domain, expires &#125; = &#123;&#125;</span>) </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此例为第三个参数提供了一个空对象作为其默认值。给解构的参数提供默认值，也就意味着若未向 <code>setCookie()</code> 函数传递第三个参数，则 <code>secure</code> 、 <code>path</code> 、 <code>domain</code> 与 <code>expires</code> 的值全都会是 <code>undefined</code> ，此时不会有错误被抛出。</p>
<h3 id="参数解构的默认值"><a href="#参数解构的默认值" class="headerlink" title="参数解构的默认值"></a>参数解构的默认值</h3><p>你可以为参数解构提供可解构的默认值，就像在解构赋值时所做的那样，只需在其中每个参数后面添加等号并指定默认值即可。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setCookie</span>(<span class="params">name, value,</span></span></div><div class="line">    &#123;</div><div class="line">        secure = false,</div><div class="line">        path = <span class="string">"/"</span>,</div><div class="line">        domain = <span class="string">"example.com"</span>,</div><div class="line">        expires = new Date(Date.now() + 360000000)</div><div class="line">    &#125; = &#123;&#125;</div><div class="line">) &#123;</div><div class="line"></div><div class="line">    <span class="comment">// ...</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此代码中参数解构给每个属性都提供了默认值，所以你可以避免检查指定属性是否已被传入（以便在未传入时使用正确的值）。而整个解构的参数同样有一个默认值，即一个空对象，令该参数成为可选参数。这么做使得函数声明看起来比平时要复杂一些，但却是为了确保每个参数都有可用的值而付出的微小代价。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>解构使得在 JS 中操作对象与数组变得更容易。使用熟悉的对象字面量与数组字面量语法，可以将数据结构分离并只获取你感兴趣的信息。对象解构模式允许你从对象中进行提取，而数组模式则能用于数组。</p>
<p>对象与数组解构都能在属性或项未定义时为其提供默认值；在赋值表达式右侧的值为 <code>null</code> 或 <code>undefined</code>时，两种模式都会抛出错误。你也可以在深层嵌套的数据结构中使用对象与数组解构，下行到该结构的任意深度。</p>
<p>使用 <code>var</code> 、 <code>let</code> 或 <code>const</code> 的解构声明来创建变量，就必须提供初始化器。解构赋值能替代其他赋值，并且允许你把值解构到对象属性或已存在的变量上。</p>
<p>参数解构使用解构语法作为函数的参数，让“选项”（ options ）对象更加透明。你实际感兴趣的数据可以与具名参数一并列出。解构的参数可以是对象模式、数组模式或混合模式，并且你能使用它们的所有特性。</p>

  </article>
  <div class="random-toc-area">
  <button class="btn-hide-toc btn-hide-toc-show" style="display: none" onclick="TOCToggle()">Show TOC</button>
  <button class="btn-hide-toc btn-hide-toc-hide" onclick="TOCToggle()">Hide TOC</button>
  <div class="random-toc">
    <h2>Table of Content</h2>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#解构为何有用？"><span class="toc-text">解构为何有用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象解构"><span class="toc-text">对象解构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解构赋值"><span class="toc-text">解构赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#默认值"><span class="toc-text">默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#赋值给不同的本地变量名"><span class="toc-text">赋值给不同的本地变量名</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#嵌套的对象解构"><span class="toc-text">嵌套的对象解构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数组解构"><span class="toc-text">数组解构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解构赋值-1"><span class="toc-text">解构赋值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#默认值-1"><span class="toc-text">默认值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#嵌套的解构"><span class="toc-text">嵌套的解构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#剩余项"><span class="toc-text">剩余项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#混合解构"><span class="toc-text">混合解构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#参数解构"><span class="toc-text">参数解构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#解构的参数是必需的"><span class="toc-text">解构的参数是必需的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参数解构的默认值"><span class="toc-text">参数解构的默认值</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#总结"><span class="toc-text">总结</span></a></li></ol>
  </div>
</div>

  
<nav id="pagination">
  
    <a href="/2017/04/25/Flex布局/" class="prev">&larr; Prev post 老生常谈的Flex布局</a>
  

  

  
</nav>

  <!-- JiaThis Button BEGIN -->

<!-- JiaThis Button END -->


      
      
      
    </div>
  </div>

  <div id="bottom-outer">
    <div id="bottom-inner">
      Site by Life using
      <a href="http://hexo.io">Hexo</a> & <a href="https://github.com/stiekel/hexo-theme-random">Random</a>
      <br>
      
    </div>
  </div>
</div>

</div>



<div id="user-card">
  <div class="center-field">
    <img class="avatar" src="http://7te9fe.com1.z0.glb.clouddn.com/default_avatar.jpg">
    <p id="description"></p>
    <ul class="social-icon">
  
  
    <li>
      <a href="https://github.com/azhengi">
        
          <i class="icon iconfont github">&#xe606;</i>
        
      </a>
    </li>
  
</ul>
  </div>
</div>


<div id="btn-view">Hide</div>

<script>
// is trigger analytics / tongji script
var isIgnoreHost = false;

if(window && window.location && window.location.host) {
  isIgnoreHost = ["localhost","127.0.0.1"].some(function(address){
    return 0 === window.location.host.indexOf(address);
  });
}

var isTriggerAnalytics = !( true && isIgnoreHost );

</script>




  
  
    <script src="/js/jquery-2.2.3.min.js"></script>
  
    <script src="/js/vegas.min.js"></script>
  
    <script src="/js/random.js"></script>
  
    <script src="/js/highlight.pack.js"></script>
  
    <script src="/js/jquery.mousewheel.pack.js"></script>
  
    <script src="/js/jquery.fancybox.pack.js"></script>
  
    <script src="/js/jquery.fancybox-thumbs.js"></script>
  
    <script src="/js/plyr.js"></script>
  

<script>

  // fancybox
  var backgroundImages = [];
  
  $('#post').each(function(i){
    $(this).find('img').each(function(){
      if ($(this).parent().hasClass('fancybox') || $(this).parent().hasClass('fancybox-thumb')) return;
      var alt = this.alt || this.title;
      if (alt) $(this).after('<span class="caption">' + alt + '</span>');
      $(this).wrap('<a href="' + this.src + '" title="' + alt + '" class="fancybox"></a>');
    });
    $(this).find('.fancybox').each(function(){
      $(this).attr('rel', 'post' + i);
    });
  });
  $(".fancybox").fancybox();

var vegasConfig = {"preload­Image":true,"transition":["slideLeft2","slideRight2","flash2"],"timer":true,"delay":5000,"shuffle":true,"count":28};
var unsplashConfig = {"gravity":"north"};
// is show background images
var turnoffBackgroundImage = false;



  turnoffBackgroundImage = true;


var backgroundColor = "34495E";

$(".fancybox-thumb").fancybox({
  prevEffect: 'none',
  nextEffect: 'none',
  helpers: {
    title: {
      type: 'outside'
    },
    thumbs: {
      width: 50,
      height: 50
    }
  }
});

// show video with plyr
$(".video-container iframe").each(function(i){
  var url = $(this).attr('src');
  var id = url.split('/').pop();
  var plyrContainer = document.createElement('div');
  plyrContainer.className = 'plyr';
  var plyrElement = document.createElement('div');
  plyrElement.dataset.videoId = id;
  switch(true) {
    case url.search('youtube.com') >= 0:
      plyrElement.dataset.type = 'youtube';
      break;
    case url.search('vimeo.com') >= 0:
      plyrElement.dataset.type = 'vimeo';
      break;
    default:
      return;
  };
  plyrContainer.appendChild(plyrElement);
  $(this).parent().html(plyrContainer);
});
plyr.setup('.plyr', {iconUrl: '/css/sprite.svg'});
</script>
</body>
</html>

